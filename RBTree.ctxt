#BlueJ class context
comment0.target=RBTree
comment0.text=\r\n\ This\ class\ represents\ a\ red\ black\ tree.\r\n\ <p>\r\n\ It\ holds\ information\ like\ it's\ root,\ the\ world\ in\ which\ the\ tree\ is\ present,\ and\ the\ main\ Node\ Pointer\r\n\ \r\n\ @see\ NodeRB\r\n\ @see\ NodePointer\r\n\ @author\ Ro\u0219ca\ Paul-Teodor\ \r\n\ @version\ 1.0\ (22/12/2020)\r\n
comment1.params=myWorld
comment1.target=RBTree(Background)
comment1.text=\r\n\ Constructor\ for\ our\ tree.\r\n\ <p>\r\n\ It\ set's\ the\ tree's\ world\ and\ root\ (default\ null)\ and\ retrieves\ some\ \ from\ the\ world.\r\n
comment10.params=node
comment10.target=void\ startSpacing(NodeRB)
comment10.text=\r\n\ Method\ that\ gathers\ some\ information\ about\ a\ node\ and\ calls\ for\ it's\ spacing\ (to\ make\ the\ tree\ uniform)\ accordingly.\r\n\ \r\n\ @see\ fixSpacing()\r\n\ \r\n\ @param\ node\ the\ node\ from\ which\ we\ start\ spacing\r\n
comment11.params=parent\ leftChild
comment11.target=void\ fixSpacing(NodeRB,\ int)
comment11.text=\r\n\ Method\ that\ fixes\ the\ spacing\ of\ the\ nodes,\ using\ {@link\ spaceNodes()}.\r\n\ \r\n\ @param\ parent\ the\ node\ for\ which\ we\ apply\ spacing\ (always\ a\ parent\ of\ another\ node)\r\n\ @param\ leftChild\ flag\ that\ tells\ us\ if\ the\ original\ child\ (usually\ a\ newly\ inserted\ node)\ is\ a\ left\ or\ a\ right\ child\r\n
comment12.params=node\ right
comment12.target=void\ spaceNodes(NodeRB,\ int)
comment12.text=\r\n\ Method\ that\ moves\ a\ subtree\ by\ one\ unit\ [50px]\ to\ the\ right\ or\ left\ accordingly.\r\n\ \r\n\ @param\ node\ the\ root\ of\ the\ subreee\ we\ want\ to\ move\r\n\ @param\ right\ flag\ that\ tells\ us\ if\ we\ need\ to\ move\ right\ or\ left\ (-1\ -\ left;\ 1\ -\ right)\r\n
comment13.params=z
comment13.target=void\ insertColorFixup(NodeRB)
comment13.text=\ \r\n\ Method\ that\ handles\ the\ recoloring\ of\ the\ tree\ after\ inserting\ a\ node.\r\n\ \r\n\ @param\ z\ the\ node\ from\ which\ we\ start\ recoloring\r\n
comment14.params=x
comment14.target=void\ leftRotate(NodeRB)
comment14.text=\r\n\ Method\ for\ rotating\ a\ node\ left,\ and\ making\ sure\ the\ tree\ stays\ uniform\ (visually).\r\n\ \r\n\ @param\ x\ the\ node\ which\ we\ use\ a\ pivot\ for\ the\ rotation\r\n
comment15.params=y
comment15.target=void\ rightRotate(NodeRB)
comment15.text=\r\n\ Method\ for\ rotating\ a\ node\ right,\ and\ making\ sure\ the\ tree\ stays\ uniform\ (visually).\r\n\ \r\n\ @param\ x\ the\ node\ which\ we\ use\ a\ pivot\ for\ the\ rotation\r\n
comment16.params=r
comment16.target=void\ setRoot(NodeRB)
comment16.text=\r\n\ Method\ for\ setting\ the\ root\ of\ the\ tree.\r\n\ \r\n\ @param\ r\ the\ new\ root\r\n
comment17.params=
comment17.target=NodeRB\ getRoot()
comment17.text=\r\n\ Method\ for\ getting\ the\ root\ of\ the\ tree.\r\n\ \r\n\ @return\ the\ root\ of\ the\ tree\r\n
comment18.params=
comment18.target=NodePointer\ getNodePointer()
comment18.text=\r\n\ Method\ for\ getting\ the\ main\ pointer\ of\ the\ tree.\r\n\ \r\n\ @return\ main\ pointer\r\n
comment2.params=k\ findFirst
comment2.target=NodeRB\ searchNode(int,\ boolean)
comment2.text=\r\n\ Method\ for\ searching\ a\ node\ with\ a\ specific\ key\ in\ the\ tree\ and/or\ it's\ parent\r\n\ \r\n\ @param\ k\ the\ key\ for\ which\ we\ search\r\n\ @param\ findFirst\ flag\ that\ tells\ us\ if\ we're\ actually\ searching\ for\ a\ node\ (<b>true</b>)\ or\ if\ we're\ searching\ for\ it's\ parent\ (<b>false</b>)\r\n\ @return\ the\ node\ we're\ searching\ for,\ or\ it's\ parent\ (if\ findFirst\ flag\ is\ true),\ the\ node's\ parent\ otherwise\r\n\ \r\n
comment3.params=k
comment3.target=NodeRB\ search(int)
comment3.text=\r\n\ Method\ used\ excusively\ for\ finding\ a\ node\ in\ the\ tree\ (if\ the\ node\ is\ present\ in\ the\ tree).\ It\ uses\ {@link\ searchNode}\ with\ the\ <i>findFirst</i>\ flag.\r\n\ \r\n\ @param\ k\ the\ key\ of\ the\ node\ we're\ looking\ for\r\n\ @return\ the\ searched\ node,\ or\ it's\ supossed\ parent\ if\ the\ not\ is\ not\ present\ in\ tree\r\n
comment4.params=node\ scsPointer
comment4.target=NodeRB\ successor(NodeRB,\ NodePointer)
comment4.text=\r\n\ Method\ that\ searches\ for\ the\ successor\ of\ a\ node\ and\ moves\ a\ pointer\ for\ visualising\ the\ search.\r\n\ \r\n\ @param\ node\ the\ node's\ who's\ successor\ we\ search\ for\r\n\ @param\ scsPointer\ the\ pointer\ to\ the\ successor\r\n\ \r\n\ @return\ the\ successor\ of\ the\ node\ \r\n
comment5.params=k
comment5.target=void\ deleteKey(int)
comment5.text=\r\n\ Method\ that\ searches\ for\ a\ node\ with\ a\ specific\ key\ and\ calls\ for\ it's\ deletion\ if\ the\ node\ is\ present\ in\ tree.\r\n\ \r\n\ @see\ search()\r\n\ @see\ delete()\r\n\ \r\n\ @param\ k\ the\ key\ of\ the\ node\ we\ want\ to\ delete\r\n
comment6.params=node
comment6.target=void\ delete(NodeRB)
comment6.text=\r\n\ Method\ that\ deletes\ a\ node\ from\ the\ tree,\ fixes\ the\ visualisation\ and\ calls\ for\ tree\ recoloring\ if\ necessary.\r\n\ \r\n\ @see\ deleteColorFixup\r\n\ \r\n\ @param\ node\ the\ node\ we\ wish\ to\ delete\ from\ the\ tree\r\n
comment7.params=node
comment7.target=boolean\ getColorOfNode(NodeRB)
comment7.text=\r\n\ Method\ used\ for\ getting\ the\ color\ of\ a\ node.\ It\ is\ used\ because\ it\ handles\ the\ null\ leafs\ case.\r\n\ \r\n\ @returns\ true\ -\ the\ node\ is\ black\ (or\ null)\r\n\ \ \ \ \ \ \ \ \ \ false\ -\ the\ node\ is\ red\r\n
comment8.params=x\ xParent
comment8.target=void\ deleteColorFixup(NodeRB,\ NodeRB)
comment8.text=\r\n\ Method\ that\ handles\ the\ recoloring\ of\ the\ tree\ in\ case\ of\ the\ deletion\ of\ a\ black\ node.\ It\ requires\ the\ parent\ parameter,\ because\ we\ can't\ determine\ the\ parent\ of\ a\ null\ node.\r\n\ \r\n\ @param\ x\ the\ node\ from\ which\ we\ start\ recoloring\r\n\ @param\ xParent\ it's\ parent\r\n
comment9.params=k
comment9.target=void\ insert(int)
comment9.text=\r\n\ Method\ for\ inserting\ a\ node\ into\ the\ tree.\ It\ also\ makes\ sure\ the\ tree\ looks\ uniform\ (visually).\r\n\ \r\n\ @see\ insertColorFixup()\r\n\ \r\n\ @param\ k\ the\ key\ of\ the\ node\ we\ want\ to\ insert\r\n
numComments=19
